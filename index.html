<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Hard Corps-style Prototype (Three.js)</title>
<style>
  html,body{height:100%;margin:0;background:#071021;color:#dff9ff;font-family:Inter,system-ui,Arial}
  #ui{position:fixed;left:12px;top:12px;z-index:30}
  #ui .big{font-weight:800;font-family:monospace}
  #ui .small{opacity:0.85;font-size:13px;margin-top:6px}
  #hud {position:fixed;right:12px;top:12px;color:#eafcff;text-align:right;z-index:30}
  #overlay{position:fixed;left:0;right:0;bottom:12px;display:flex;justify-content:center;gap:8px;z-index:30}
  .touchBtn{padding:12px 14px;border-radius:10px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.06);color:#fff;font-weight:700;user-select:none}
  canvas{display:block}
  #message{position:fixed;left:0;right:0;top:45%;text-align:center;color:#fff;font-family:monospace;z-index:40}
</style>
</head>
<body>
<div id="ui">
  <div class="big" id="score">SCORE: 0</div>
  <div class="small" id="lives">LIVES: 3</div>
  <div class="small" id="help">Keys: ←/A →/D = move · W/↑ = jump · Space = shoot · E = dash · R restart · M mute</div>
</div>
<div id="hud">
  <div id="bossHealth" style="font-family:monospace"></div>
</div>

<div id="overlay">
  <div id="leftPad" class="touchBtn">◀</div>
  <div id="rightPad" class="touchBtn">▶</div>
  <div id="jumpPad" class="touchBtn">▲</div>
  <div id="shootPad" class="touchBtn">FIRE</div>
  <div id="dashPad" class="touchBtn">DASH</div>
</div>

<div id="message" style="display:none"></div>

<!-- Three.js as ES module from CDN -->
<script type="module">
// Imports
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// ----------------- Basic renderer & scene -----------------
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x071021, 0.0012);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Camera: side/behind to create 3D side-scroller feel
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);
camera.position.set(0, 60, 120);
camera.lookAt(0, 40, 0);

// Resize
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ----------------- Lighting -----------------
const ambient = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(ambient);
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(200,300,200);
dir.castShadow = true;
dir.shadow.mapSize.set(2048,2048);
dir.shadow.camera.left=-200; dir.shadow.camera.right=200; dir.shadow.camera.top=200; dir.shadow.camera.bottom=-200;
scene.add(dir);

// subtle rim neon lights
const neon1 = new THREE.PointLight(0x7afcff, 0.6, 300);
neon1.position.set(-100, 80, 60);
scene.add(neon1);
const neon2 = new THREE.PointLight(0xff52e5, 0.55, 300);
neon2.position.set(400, 120, -80);
scene.add(neon2);

// ----------------- Ground + environment (simple modular geometry) -----------------
const groundGeo = new THREE.PlaneGeometry(4000, 4000);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x06121a, roughness: 0.9, metalness: 0.1 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.position.y = 0;
ground.receiveShadow = true;
scene.add(ground);

// add neon platforms as boxes
const platforms = [];
function createPlatform(x,z,w,h,y=12){
  const mat = new THREE.MeshStandardMaterial({ color: 0x0b2130, emissive: 0x082632, roughness:0.7 });
  const geom = new THREE.BoxGeometry(w, h, 60);
  const m = new THREE.Mesh(geom, mat);
  m.position.set(x, y, z);
  m.receiveShadow = true;
  m.castShadow = false;
  scene.add(m);
  platforms.push(m);
  // neon rim
  const rim = new THREE.Mesh(new THREE.BoxGeometry(w*0.95, h*0.3, 62), new THREE.MeshBasicMaterial({ color: 0x7afcff, transparent:true, opacity:0.06 }));
  rim.position.set(x, y + h/2 + 0.5, z);
  scene.add(rim);
}
for(let i=0;i<36;i++){
  createPlatform(100 + i*140, (i%2? -20:20), 120 + (Math.random()*80|0), 6, 30 + Math.sin(i*0.6)*18);
}

// ----------------- Player (procedural low-poly 'model' to start) -----------------
const player = new THREE.Group();
player.position.set(60, 40, 0);
player.castShadow = true;
player.receiveShadow = true;
scene.add(player);

// body
const bodyMat = new THREE.MeshStandardMaterial({ color:0xffd66b, roughness:0.5, metalness:0.1, emissive:0x000000 });
const bodyGeo = new THREE.BoxGeometry(10, 16, 8);
const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
bodyMesh.position.set(0, 0, 0);
bodyMesh.castShadow = true;
player.add(bodyMesh);

// head visor
const visor = new THREE.Mesh(new THREE.BoxGeometry(8,4,6), new THREE.MeshStandardMaterial({ color:0x7afcff, emissive:0x2eefff, emissiveIntensity:0.9 }));
visor.position.set(0, 10, 0);
player.add(visor);

// gun (simple)
const gun = new THREE.Mesh(new THREE.BoxGeometry(8,3,4), new THREE.MeshStandardMaterial({ color:0x071018 }));
gun.position.set(10, 0, 0);
player.add(gun);

// physics + state
const state = {
  vx:0, vy:0, speed: 1.6, runMultiplier: 1.8, onGround:false,
  jumpPower: 9.8, canDoubleJump:true, cooldown:0, facing:1,
  dashCool:0, dashing:false, dashTime:0
};
let score = 0, lives = 3;
document.getElementById('score').textContent = 'SCORE: ' + score;
document.getElementById('lives').textContent = 'LIVES: ' + lives;

// ----------------- Enemies & bullets -----------------
const enemies = []; // {mesh, vx, hp, type}
const bullets = []; // player bullets
const eBullets = []; // enemy bullets
const particles = [];

// simple enemy factory
function spawnEnemy(x,y,type='walker'){
  const mat = new THREE.MeshStandardMaterial({ color: type==='shooter' ? 0x9bff7a : 0xff6b95, roughness:0.6 });
  const geom = new THREE.BoxGeometry(10,14,8);
  const m = new THREE.Mesh(geom, mat);
  m.position.set(x, y, (Math.random()*20 - 10));
  m.castShadow = true;
  scene.add(m);
  const obj = { mesh: m, vx: type==='walker' ? (-0.6 - Math.random()*0.6) : 0, hp: 1 + (Math.random()>0.75?1:0), type, cooldown:80 + Math.random()*120 };
  enemies.push(obj);
}
for(let i=0;i<6;i++) spawnEnemy(360 + i*220, 40, Math.random()<0.6 ? 'walker' : 'shooter');

// boss (simple)
let boss = null;
function spawnBoss(){
  const mat = new THREE.MeshStandardMaterial({ color:0xff5ad6, emissive: 0xff5ad6, emissiveIntensity: 0.08 });
  const geom = new THREE.BoxGeometry(80,60,40);
  const m = new THREE.Mesh(geom, mat);
  m.position.set(2200, 110, 0);
  m.castShadow = true;
  scene.add(m);
  boss = { mesh:m, hp: 60, phase:0, timer:0 };
}
spawnBoss();

// ----------------- Simple collision helpers -----------------
function aabb(mesh){
  const b = new THREE.Box3().setFromObject(mesh);
  return b;
}

// ----------------- Camera follow (side scroll feel) -----------------
function updateCamera(){
  // keep player slightly left of center
  const targetX = Math.max(0, player.position.x + 20);
  // camera will follow on x axis; slight z/height offset
  camera.position.x += (targetX - camera.position.x) * 0.08;
  camera.position.y += ((player.position.y + 40) - camera.position.y) * 0.06;
  camera.lookAt(player.position.x + 40, player.position.y + 10, 0);
}

// ----------------- Input handling -----------------
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Space') e.preventDefault(); if (e.code==='KeyR') restart(); if (e.code==='KeyM') toggleMute(); });
window.addEventListener('keyup', e => keys[e.code] = false);

// touch UI mapping
document.getElementById('leftPad').addEventListener('touchstart', e=>{ e.preventDefault(); keys['ArrowLeft']=true; });
document.getElementById('leftPad').addEventListener('touchend', e=>{ e.preventDefault(); keys['ArrowLeft']=false; });
document.getElementById('rightPad').addEventListener('touchstart', e=>{ e.preventDefault(); keys['ArrowRight']=true; });
document.getElementById('rightPad').addEventListener('touchend', e=>{ e.preventDefault(); keys['ArrowRight']=false; });
document.getElementById('jumpPad').addEventListener('touchstart', e=>{ e.preventDefault(); keys['ArrowUp']=true; setTimeout(()=>keys['ArrowUp']=false, 200); });
document.getElementById('shootPad').addEventListener('touchstart', e=>{ e.preventDefault(); keys['Space']=true; setTimeout(()=>keys['Space']=false, 120); });
document.getElementById('dashPad').addEventListener('touchstart', e=>{ e.preventDefault(); keys['KeyE']=true; setTimeout(()=>keys['KeyE']=false, 220); });

// ----------------- Audio (simple WebAudio FX, can be replaced) -----------------
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null, muted = false;
function ensureAudio(){ if (!audioCtx) audioCtx = new AudioCtx(); }
function playBeep(freq=600, type='sine', dur=0.08, vol=0.06){
  if (muted) return; ensureAudio();
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination);
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
  o.start(); o.stop(audioCtx.currentTime + dur + 0.02);
}
function playShootSfx(){ playBeep(1200,'square',0.05,0.08); }
function playHitSfx(){ playBeep(240,'sawtooth',0.12,0.08); }
function playExplosionSfx(){ if (muted) return; ensureAudio(); const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.18, audioCtx.sampleRate); const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i] = (Math.random()*2-1)*Math.exp(-3*i/d.length); const s = audioCtx.createBufferSource(), g = audioCtx.createGain(); s.buffer = buf; s.connect(g); g.connect(audioCtx.destination); g.gain.value = 0.25; s.start(); }

// ----------------- Gameplay: update physics, enemies, bullets -----------------
const GRAV = 0.6;
function update(dt){
  // Player movement
  const move = (keys['ArrowRight']||keys['KeyD']?1:0) - (keys['ArrowLeft']||keys['KeyA']?1:0);
  const running = keys['ShiftLeft'] || keys['ShiftRight'];
  const speed = state.speed * (running ? state.runMultiplier : 1);
  state.vx = move * speed;
  if (move !== 0) state.facing = move > 0 ? 1 : -1;

  // dash
  if ((keys['KeyE']) && state.dashCool <= 0 && !state.dashing){
    state.dashing = true; state.dashTime = 18; state.dashCool = 80;
    playBeep(800,'sawtooth',0.06,0.06);
  }

  if (state.dashing){
    state.dashTime--;
    state.vx = state.facing * 8;
    if (state.dashTime <= 0) state.dashing = false;
  } else {
    if (state.dashCool > 0) state.dashCool--;
  }

  // jump
  if ((keys['ArrowUp']||keys['KeyW']) && state.onGround){
    state.vy = state.jumpPower * -1; state.onGround = false; state.canDoubleJump = true;
    playBeep(820,'sine',0.09,0.06);
    keys['ArrowUp'] = false; // small lock to prevent hold
  } else if ((keys['ArrowUp']||keys['KeyW']) && !state.onGround && state.canDoubleJump){
    // double jump
    state.vy = state.jumpPower * -0.85; state.canDoubleJump = false;
    playBeep(900,'triangle',0.08,0.06);
    keys['ArrowUp'] = false;
  }

  // shooting
  if ((keys['Space']||keys['KeyK']) && state.cooldown <= 0){
    // spawn bullet
    const dir = state.facing;
    const b = { x: player.position.x + dir*12, y: player.position.y + 4, z: player.position.z, vx: dir*18, life: 80, mesh: null };
    // visual bullet
    const geom = new THREE.SphereGeometry(1.6,6,6);
    const mat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xffffff });
    const mb = new THREE.Mesh(geom, mat);
    mb.position.set(b.x,b.y,b.z); scene.add(mb);
    mb.castShadow = false;
    b.mesh = mb;
    bullets.push(b);
    state.cooldown = 8;
    playShootSfx();
  }
  if (state.cooldown > 0) state.cooldown--;

  // physics integrate
  player.position.x += state.vx;
  player.position.y -= state.vy; // y positive upward in scene coordinates: we'll invert
  state.vy -= GRAV * (dt*60);

  // ground collision
  if (player.position.y <= 12){
    player.position.y = 12;
    state.vy = 0;
    state.onGround = true;
    state.canDoubleJump = true;
  }

  // platform collisions (simple AABB with platforms)
  for (const p of platforms){
    const px = p.position.x, py = p.position.y + 6, pw = p.geometry.parameters.width, ph = p.geometry.parameters.height;
    // only collide when above platform and within x range
    const left = px - pw/2, right = px + pw/2;
    if (player.position.x > left - 6 && player.position.x < right + 6){
      const platTop = p.position.y + (p.geometry.parameters.height/2) + 6;
      if (player.position.y < platTop + 1 && player.position.y > platTop - 22 && state.vy < 0){
        player.position.y = platTop + 1;
        state.vy = 0;
        state.onGround = true;
        state.canDoubleJump = true;
      }
    }
  }

  // clamp player inside level
  if (player.position.x < 10) player.position.x = 10;
  if (player.position.x > WORLD_W - 20) player.position.x = WORLD_W - 20;

  // update bullets
  for (let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx * (dt*60);
    b.mesh.position.set(b.x, b.y, b.z);
    b.life--;
    if (b.life <= 0 || Math.abs(b.x - camera.position.x) > 2000){
      scene.remove(b.mesh); bullets.splice(i,1); continue;
    }
    // check collision with enemies
    for (let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      const ex = e.mesh.position.x, ey = e.mesh.position.y;
      if (Math.abs(b.x - ex) < 12 && Math.abs(b.y - ey) < 18){
        // hit
        e.hp -= 1;
        scene.remove(b.mesh);
        bullets.splice(i,1);
        spawnDamageParticles(ex, ey, 10, 0xff6b95);
        playHitSfx();
        if (e.hp <= 0){
          scene.remove(e.mesh);
          enemies.splice(j,1);
          score += 120;
          document.getElementById('score').textContent = 'SCORE: ' + score;
        }
        break;
      }
    }
    // boss hit
    if (boss){
      const bex = boss.mesh.position.x, bey = boss.mesh.position.y;
      if (Math.abs(b.x - bex) < 40 && Math.abs(b.y - bey) < 50){
        boss.hp -= 1;
        scene.remove(b.mesh); bullets.splice(i,1);
        spawnDamageParticles(bex, bey, 14, 0xff52e5);
        playHitSfx();
        if (boss.hp <= 0){
          scene.remove(boss.mesh);
          boss = null;
          score += 1000;
          document.getElementById('score').textContent = 'SCORE: ' + score;
        }
      }
    }
  }

  // update enemies
  for (let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.mesh.position.x += e.vx * (dt*60);
    e.cooldown -= (dt*60);
    if (e.type === 'shooter' && e.cooldown <= 0){
      e.cooldown = 80 + Math.random()*100;
      // spawn enemy bullet
      const eb = { x: e.mesh.position.x - 4, y: e.mesh.position.y + 2, vx: (player.position.x < e.mesh.position.x ? -1 : 1) * 6, mesh: null, life: 180 };
      const g = new THREE.SphereGeometry(1.8,6,6);
      const m = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color:0xff8a8a, emissive:0xff8a8a }));
      m.position.set(eb.x, eb.y, eb.z||0); scene.add(m); eb.mesh = m;
      eBullets.push(eb);
    }
    // collision with player
    if (Math.abs(e.mesh.position.x - player.position.x) < 10 && Math.abs(e.mesh.position.y - player.position.y) < 18){
      // destroy enemy and damage player
      spawnDamageParticles(e.mesh.position.x, e.mesh.position.y, 12, 0xff6b95);
      scene.remove(e.mesh); enemies.splice(i,1);
      damagePlayer();
    }
    if (e.mesh.position.x < camera.position.x - 400) { scene.remove(e.mesh); enemies.splice(i,1); }
  }

  // update enemy bullets
  for (let i=eBullets.length-1;i>=0;i--){
    const b = eBullets[i];
    b.x += b.vx * (dt*60);
    b.mesh.position.set(b.x, b.y, b.z||0);
    b.life--;
    if (b.life <= 0) { scene.remove(b.mesh); eBullets.splice(i,1); continue; }
    if (Math.abs(b.x - player.position.x) < 8 && Math.abs(b.y - player.position.y) < 16){
      scene.remove(b.mesh); eBullets.splice(i,1);
      spawnDamageParticles(player.position.x, player.position.y, 12, 0xffd66b);
      damagePlayer();
    }
  }

  // boss logic
  if (boss){
    boss.timer += dt*60;
    boss.mesh.position.x += Math.sin(boss.timer*0.02)*0.6;
    if (boss.timer % 120 < 1){
      // fire pattern: spread bullets
      for (let k=-3;k<=3;k++){
        const bvx = (k/2) * 2 + ((player.position.x < boss.mesh.position.x) ? -1 : 1)* 2;
        const bb = { x: boss.mesh.position.x - 10, y: boss.mesh.position.y - 5 + k*6, vx: bvx, mesh:null, life:220 };
        const g = new THREE.SphereGeometry(2.5,6,6);
        const m = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color:0xffb86b, emissive:0xffb86b }));
        m.position.set(bb.x, bb.y, 0); scene.add(m); bb.mesh = m;
        eBullets.push(bb);
      }
      playBeep(520,'sine',0.06,0.06);
    }
    // boss collision with player
    if (Math.abs(boss.mesh.position.x - player.position.x) < 40 && Math.abs(boss.mesh.position.y - player.position.y) < 40){
      damagePlayer();
    }
    // display boss health
    document.getElementById('bossHealth').textContent = 'BOSS HP: ' + (boss ? Math.max(0,boss.hp) : '');
  } else {
    document.getElementById('bossHealth').textContent = '';
  }

  // particles update
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy -= 0.18;
    p.life--; if (p.life <= 0){ scene.remove(p.mesh); particles.splice(i,1); continue; }
    p.mesh.position.set(p.x, p.y, p.z);
    const fade = Math.max(0.05, p.life/40); p.mesh.material.opacity = fade;
  }

  // remove off-world bullets/enemies
  // spawn more enemies occasionally ahead
  if (enemies.filter(e=>e.mesh.position.x > camera.position.x).length < 6){
    const sx = camera.position.x + 600 + Math.random()*600;
    if (sx < WORLD_W - 200) spawnEnemy(sx, 40, Math.random()<0.6?'walker':'shooter');
  }

  // camera update
  updateCamera();

  // check player fall out of world
  if (player.position.y < -120){
    damagePlayer();
  }

  // update UI
  document.getElementById('score').textContent = 'SCORE: ' + score;
}

// spawn small damage particles
function spawnDamageParticles(x,y,count,color=0xffb86b){
  for (let i=0;i<count;i++){
    const geom = new THREE.BoxGeometry(1.6,1.6,1.6);
    const mat = new THREE.MeshBasicMaterial({ color });
    const m = new THREE.Mesh(geom, mat); m.position.set(x + (Math.random()*10-5), y + (Math.random()*10-5), Math.random()*10-5);
    scene.add(m);
    particles.push({ mesh:m, x:m.position.x, y:m.position.y, z:m.position.z, vx:(Math.random()*2-1)*2, vy: (Math.random()*2-1)*2, life: 18 + Math.random()*18 });
  }
  playExplosionSfx();
}

// damage player
function damagePlayer(){
  lives -= 1; document.getElementById('lives').textContent = 'LIVES: ' + lives;
  spawnDamageParticles(player.position.x, player.position.y, 20, 0xffd66b);
  playHitSfx();
  if (lives <= 0){
    running = false; showMessage('GAME OVER — Press R to restart');
  } else {
    // respawn slightly behind camera
    player.position.x = Math.max(40, camera.position.x - 120);
    player.position.y = 60;
    state.vx = 0; state.vy = 0;
  }
}

// ----------------- Render loop -----------------
let running = true;
let prevTime = performance.now();
function animate(){
  const now = performance.now();
  const dt = Math.min(0.033, (now - prevTime)/1000);
  prevTime = now;
  if (running){ update(dt); }
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// ----------------- Helper: show center message -----------------
function showMessage(txt){
  const m = document.getElementById('message');
  m.style.display = txt ? 'block' : 'none';
  m.innerText = txt || '';
}

// ----------------- Player initial pos setup -----------------
player.position.set(60, 40, 0);

// ----------------- Controls: keyboard actions for testing -----------------
function restart(){
  // cleanup
  enemies.forEach(e=>scene.remove(e.mesh)); enemies.length = 0;
  bullets.forEach(b=>scene.remove(b.mesh)); bullets.length = 0;
  eBullets.forEach(b=>scene.remove(b.mesh)); eBullets.length = 0;
  particles.forEach(p=>scene.remove(p.mesh)); particles.length = 0;
  if (boss) scene.remove(boss.mesh); boss = null;
  // reset state
  player.position.set(60, 40, 0);
  state.vx = 0; state.vy = 0; state.onGround = true; state.canDoubleJump = true; state.cooldown = 0; state.dashCool = 0;
  score = 0; lives = 3;
  document.getElementById('score').textContent = 'SCORE: ' + score;
  document.getElementById('lives').textContent = 'LIVES: ' + lives;
  // spawn enemies and boss
  for(let i=0;i<6;i++) spawnEnemy(360 + i*220, 40, Math.random()<0.6 ? 'walker' : 'shooter');
  spawnBoss();
  running = true; showMessage('');
}
window.restart = restart;

// mute toggle
function toggleMute(){ muted = !muted; if (!muted){ ensureAudio(); } }
window.toggleMute = toggleMute;

// resume audio on first gesture
window.addEventListener('pointerdown', function initAudio(){
  ensureAudio(); window.removeEventListener('pointerdown', initAudio);
});

// show initial instructions
showMessage('3D Prototype: Play with keyboard or touch. Press R to restart.');

// ----------------- Notes for upgrade (readable in code) -----------------
/*
  NEXT STEPS (I can do for you):
  - Replace player/enemy boxes with proper GLTF characters (drop a .gltf/.glb and I will integrate)
  - Add proper sprite/animation blending (walk/run/jump/shoot) — needs model with animation clips
  - Replace WebAudio FX with high-quality WAV/OGG SFX (you can upload)
  - Add level progression, checkpoints, multiple levels, and true Hard Corps boss phases
  - Optimize and add post-processing (bloom, film grain) for neon effect
*/

// End of module
</script>
</body>
</html>
